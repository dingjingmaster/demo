# 面试

## C++多态

相同接口或基类的对象上具有不同的表现方式。提高代码灵活性或可扩展性。

## C++多态类型

- 编译时多态（静态多态）：编译时候确定调用哪个函数，函数重载、运算符重载实现。编译时候绑定。
- 运行时多态（动态多态）：程序运行阶段调用哪个函数，虚函数和继承实现。运行时候绑定。

## C++什么时候需要虚析构函数

基类的析构函数不是虚函数，当使用delete删除一个指向派生类的基类指针时候，只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致派生类的资源没有正确释放，造成内存泄漏。

虚析构函数确保先调用派生类的析构函数，再调用基类的析构函数，保证了对象的正确销毁。

使用虚析构函数的情况：
- 基类用于继承，并且可能通过基类指针或引用操作派生类对象
- 基类可能会被派生类扩展，而派生类可能会申请动态资源（如：new分配内存）

不需要使用虚析构函数的情况：
- 类不打算被继承（例如：final类）
- 类不会被通过基类指针或引用删除。

> 纯虚析构函数：如果一个类是抽象基类，通常需要定义纯虚析构函数，以确保派生类可以正确析构。纯虚析构函数的目的是，强制派生类实现自己的析构逻辑。

## C++深拷贝和浅拷贝

- 浅拷贝：只复制对象的成员数据（指针或基本类型），不会对对象中的指针成员分配内存空间。因此，浅拷贝后的两个对象中指针成员指向同一块内存，修改一个对象的指针数据会影响到另一个对象。
- 深拷贝：位对象的指针成员分配新的内存空间，并将原对象的指针所指向的内容复制到新的内存位置。

> 通常编译器默认使用浅拷贝

## Qt moc 机制

moc(Meta-Object Compiler)用于实现Qt的元对象系统，主要作用是提供信号与槽、动态类型信息（`qobject_case`）以及属性系统等功能。moc通过在编译过程中生成额外代码来增强C++的功能，不需要对原有C++语言进行修改。

- moc 的工作原理：moc会处理以下几个方面：信号与槽机制（为QObject子类生成信号和槽的实现代码）、元对象系统（为Qt类生成类型信息QMetaObject）、属性系统（处理`Q_PROPERTY`声明的属性）
- moc 如何工作：当使用Qt信号和槽、元对象、属性系统时候，类通常会继承自QObject并使用`Q_OBJECT`宏。moc会扫描头文件，处理这些宏生成额外C++代码，最终在编译时候将这些代码与原始的C++文件链接起来。moc根据头文件中宏生成 xxx.moc 文件（一个C++文件）、将`.moc`文件编译为目标文件`.o`，并与其他源文件一起链接生成最终的可执行文件。

## Qt 信号与槽机制

信号槽实现了不同对象之间的通信。当对象状态发生改变时候，信号被触发，其他对象的槽函数会响应这些信号。

## Qt 元对象系统

Qt的元对象系统允许你在运行时候查看对象的类型、调用对象的方法、访问对象的属性等。它是通过QMetaObject类来实现的。

- 每个继承自QObject的类都有一个自动生成的QMetaObject对象，它包含了类的元信息（如：类名、方法、信号、槽等）。
- 可以使用`QMetaObject::invokeMethod()`在运行时候调用对象的方法，也可以通过`QMetaObject::className()`获取类名。

```c++
QMetaObject::invokeMethod(qobj, "mySlot", Q_ARG(int, 42));
```
## Qt 属性系统

Qt提供了一个属性系统，可以让你通过`Q_PROPERTY`宏定义类的属性。这些属性直接与Qt界面（例如：Qt Quick）或脚本引擎（QML）进行交互。

`Q_PROPERTY`宏帮助生成属性的`set`、`get`方法以及通知信号(如：`valueChanged()`)

## Qt 自定义控件的方式

- 继承现有控件(QWidget或QGraphicsItem)
- 通过组合其他控件
- 自绘控件（QPainter绘制）
- 使用QML创建自定义控件

## MCVD模式的好处

MCVD(Model-Controller-View-Dispatcher)模式是一种用于构建用户界面（UI）应用程序的设计模式，它将传统的MVC进行了扩展，增加了一个Dispatcher（调度层）。这个模式的主要目的是优化用户界面的交互方式，增强系统的可维护性和灵活性。

MCVD模式的基本结构：
- Model（模型）：负责管理数据和业务逻辑，与外部数据库或资源交互。
- View（视图）：负责显示用户界面，展示模型的树u，并提供用户交互的界面
- Controller（控制器）：接受用户输入并通知模型进行数据更新，更新视图以反映模型的变化
- Dispatcher（调度器）：作为调度和中介层，负责协调控制器和视图的交互，确保控制器和视图之间的解耦。它可以管理多个视图之间的切换、视图的更新、以及不同模块之间的协调。

MCVD的好处：
- 增强解耦性：通过引入Dispatcher层，进一步解耦了视图和控制器的关系。传统MVC中，控制器直接与视图交互，这在复杂的应用中可能导致控制器和视图之间的耦合过高。
- 集中化的视图管理：Dispatcher层可以集中管理应用中的多个视图，尤其在涉及见到多视图或界面切换的复杂应用中。Dispatcher可以负责更新相应的视图和数据绑定，而无须每个控制器都去关心视图的切换和更新位问题。
- 简化控制器逻辑：传统MVC中，控制器不仅仅需要处理用户输入、还需要直接与视图进行将交互，这可能导致控制器代码变得复杂。通过引入Dispatcher层，控制器只需关注业务逻辑，减少了与视图的交互，控制器代码变得更加简洁和专注。
- 灵活的时间处理和路由机制：Dispatcher层提供了灵活的事件处理和路由机制，可以将用户的输入、请求或者视图更新事件进行路由和转发。它为事件驱动的应用程序提供了强大的支持，使得时间的流转变得更加清晰和高效。
- 易于测试和调试：通过解耦视图和控制器，MCVD模式有助于在不同层之间进行单元测试。
- 统一的界面更新机制：可以确保多视图应用程序中，界面更新的机制是一致的。避免视图同步的问题。

## 在不用智能指针的情况下如何避免内存泄漏

- 手动管理内存释放（使用后及时释放并置null）
- 遵循RAII（Resource Acquisition is Initialization）原则：将资源的管理和对象的声明周期绑定在一起（构造中new、析构中delete）
- 捕获异常并释放内存。

## C++迭代器的实现原理

迭代器是用于遍历容器元素的工具，类似于指针，可以通过它在容器中逐个访问元素。

迭代器是一个对象，它可以指向容器中的某个元素，并通过它来访问该元素，通过迭代器可以像使用指针一样进行元素访问，但它提供了对容器的抽象，使代码能在不同类型的容器间通用。

迭代器的基本操作：
- 解引用
- 自增
- 自减
- 比较

基于模板实现、实现类、对于连续内存可以直接用指针实现

## vector和list的实现原理和优缺点

vector使用连续内存来存储数据，自动扩展大小

list是双向链表

## python与C++之间交互原理

pythob和C++之间交互通常涉及嵌入和扩展，即在C++中调用Python代码、或者在Python中调用C++代码。主要依赖于Python C api以及FFI

- Python调用C++（扩展Python）：Python提供了Python C API，允许C++代码注册为Python模块，并在Python中调用。C++代码要使用Python头文件并实现Python兼容的C函数，通过PyObject处理Python对象，与Python解析器交互。然后编译成动态库供Python调用。
- C++调用Python（嵌入Python）：使用Python C API 调用


## Qt和js交互的原理是什么

Qt和JS的交互主要依赖于Qt WebEngine、Qt WebKit（老版本Qt）、以及Qt QML（QML中的JS引擎）。

Qt WebEngine允许在C++代码和Web前端(HTML + JS)之间进行通信，主要通过：
- QWebChannel（推荐）
- evaluteJavaScript()直接执行JS代码
- runJavaScript()(新版本API)，通过回调函数获取返回值
- 通过QWebEnginePage或QWebEngineView

## C++虚函数表

- vtable(虚表)：存储了该类的所有虚函数地址的数据，每个类有且只有一个虚函数表
- vptr(虚表指针)：每个含有虚函数的对象都有一个隐藏的指针，指向该对象所属的类的vtable

当调用虚函数时候：
- 通过对象的 vptr 找到vtable
- 在vatble中找到对应的虚函数地址
- 通过该地址调用函数

虚函数表存储在程序的数据区
- vtable是全局唯一的，存储在数据段（..data或.rodata）
- vptr存在对象的内存布局中（通常是对象的起始位置）

内存布局：
```c++
class Base
{
    int a;
    virtual void func();
};
```

```
// 64位系统, 单个类中包含虚函数
| vptr(8 bytes) | a (4 bytes) | padding (4 bytes)|

// 64位系统，继承的虚函数
| vptr_A | A 部分数据 | vptr_B | B 部分数据 |
```

类的内存布局：
Base 的vtable
|vtable(Base)|函数地址|
|:-----------|:-------|
|func1|Base::func1|

Derived的vtable
|vtable(Derived)|函数地址|
|:--------------|:-------|
|func1|Derived::func1|

## 链表过长怎么办

- 分块存储，每块包含一个小型数组或固定数量的节点
- 数据库存储
- 使用跳表或分段索引加速查询

## 头文件中静态变量，多个cpp包含

会有多个实例

## 模板中可以定义虚函数吗

可以定义虚函数、不可以定义纯虚函数(使用CRTP 奇异递归模板模式，可以)

## 如何找到两个子节点离的最近的公共父节点

- 递归DFS（深度有限搜索）：从根节点开始递归，查找p和q是否在当前子树中。当p和q在当前节点的左子树和右子树中则是、如果p和q在当前节点同一侧则在那一侧继续找、当前节点是p或q那可能是（但仍需检查子树）

## sort函数的实现用了什么排序

sort函数采用了Introsort（内省排序），结合了快排、堆排序和插入排序，以优化排序性能并避免最坏情况。

- 主要使用快排（O(NlogN)），但在最坏情况下（Q(N^2)）会退化，因此会检测递归深度
- 如果递归深度超过（O(logN)）则改用堆排序（O(NlogN)）
- 当分区规模比较小时候，改用插入排序（小规模数据下比快排更高效）

## 堆和栈的区别

|区别点|栈|堆|
|:-----|:-----|:-----|
|存储位置|由编译器自动管理，常在低地址（高增长方向）|由程序员手动分配和释放，在高地址|
|分配方式|自动分配|动态分配(new/delete)|
|分配速度|块(O(1))|慢(O(logN))要操作系统管理|
|存储内容|局部变量、函数参数、返回地址|大数据结构|
|作用域|局部作用域|全局作用域|
|无碎片化|无碎片化（连续内存）|可能碎片话（频繁分配和释放）|
|访问方式|LIFO（后进先出）|随机访问|
|异常处理|栈溢出|内存泄漏|

## hashmap 出现冲突怎么解决?

- 开放地址法：一个位置冲突时候，寻找下一个空的位置，直到找到一个空位置或遍历了整个hash表。线性探测（发生冲突，顺序查找下一个空槽）、二次探测（发生冲突，使用二次方程查找下一个空槽）、双重hash（使用第二个hash函数计算下一个槽位置）
- 链地址法：每个槽对应一个链表，当发生冲突时候，将冲突的元素插入到对应位置的链表中。头插、尾插

## 开链法出现聚集怎么解决？

- 重新hash
- 动态调整hash表大小
- 链表优化：优化聚集的链表，跳表或者平衡树

## 百万数据找出top10

用最小堆（O(n * log(k))）,k表示Top k的大小

## 排序法时间复杂度
