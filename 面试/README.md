# 面试

## C++多态

相同接口或基类的对象上具有不同的表现方式。提高代码灵活性或可扩展性。

## C++多态类型

- 编译时多态（静态多态）：编译时候确定调用哪个函数，函数重载、运算符重载实现。编译时候绑定。
- 运行时多态（动态多态）：程序运行阶段调用哪个函数，虚函数和继承实现。运行时候绑定。

## C++什么时候需要虚析构函数

基类的析构函数不是虚函数，当使用delete删除一个指向派生类的基类指针时候，只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致派生类的资源没有正确释放，造成内存泄漏。

虚析构函数确保先调用派生类的析构函数，再调用基类的析构函数，保证了对象的正确销毁。

使用虚析构函数的情况：
- 基类用于继承，并且可能通过基类指针或引用操作派生类对象
- 基类可能会被派生类扩展，而派生类可能会申请动态资源（如：new分配内存）

不需要使用虚析构函数的情况：
- 类不打算被继承（例如：final类）
- 类不会被通过基类指针或引用删除。

> 纯虚析构函数：如果一个类是抽象基类，通常需要定义纯虚析构函数，以确保派生类可以正确析构。纯虚析构函数的目的是，强制派生类实现自己的析构逻辑。

## C++深拷贝和浅拷贝

- 浅拷贝：只复制对象的成员数据（指针或基本类型），不会对对象中的指针成员分配内存空间。因此，浅拷贝后的两个对象中指针成员指向同一块内存，修改一个对象的指针数据会影响到另一个对象。
- 深拷贝：位对象的指针成员分配新的内存空间，并将原对象的指针所指向的内容复制到新的内存位置。

> 通常编译器默认使用浅拷贝

## Qt moc 机制

moc(Meta-Object Compiler)用于实现Qt的元对象系统，主要作用是提供信号与槽、动态类型信息（`qobject_case`）以及属性系统等功能。moc通过在编译过程中生成额外代码来增强C++的功能，不需要对原有C++语言进行修改。

- moc 的工作原理：moc会处理以下几个方面：信号与槽机制（为QObject子类生成信号和槽的实现代码）、元对象系统（为Qt类生成类型信息QMetaObject）、属性系统（处理`Q_PROPERTY`声明的属性）
- moc 如何工作：当使用Qt信号和槽、元对象、属性系统时候，类通常会继承自QObject并使用`Q_OBJECT`宏。moc会扫描头文件，处理这些宏生成额外C++代码，最终在编译时候将这些代码与原始的C++文件链接起来。moc根据头文件中宏生成 xxx.moc 文件（一个C++文件）、将`.moc`文件编译为目标文件`.o`，并与其他源文件一起链接生成最终的可执行文件。

## Qt 信号与槽机制

信号槽实现了不同对象之间的通信。当对象状态发生改变时候，信号被触发，其他对象的槽函数会响应这些信号。

## Qt 元对象系统

Qt的元对象系统允许你在运行时候查看对象的类型、调用对象的方法、访问对象的属性等。它是通过QMetaObject类来实现的。

- 每个继承自QObject的类都有一个自动生成的QMetaObject对象，它包含了类的元信息（如：类名、方法、信号、槽等）。
- 可以使用`QMetaObject::invokeMethod()`在运行时候调用对象的方法，也可以通过`QMetaObject::className()`获取类名。

```c++
QMetaObject::invokeMethod(qobj, "mySlot", Q_ARG(int, 42));
```
## Qt 属性系统

Qt提供了一个属性系统，可以让你通过`Q_PROPERTY`宏定义类的属性。这些属性直接与Qt界面（例如：Qt Quick）或脚本引擎（QML）进行交互。

`Q_PROPERTY`宏帮助生成属性的`set`、`get`方法以及通知信号(如：`valueChanged()`)

## Qt 自定义控件的方式

- 继承现有控件(QWidget或QGraphicsItem)
- 通过组合其他控件
- 自绘控件（QPainter绘制）
- 使用QML创建自定义控件

## MCVD模式的好处

MCVD(Model-Controller-View-Dispatcher)模式是一种用于构建用户界面（UI）应用程序的设计模式，它将传统的MVC进行了扩展，增加了一个Dispatcher（调度层）。这个模式的主要目的是优化用户界面的交互方式，增强系统的可维护性和灵活性。

MCVD模式的基本结构：
- Model（模型）：负责管理数据和业务逻辑，与外部数据库或资源交互。
- View（视图）：负责显示用户界面，展示模型的树u，并提供用户交互的界面
- Controller（控制器）：接受用户输入并通知模型进行数据更新，更新视图以反映模型的变化
- Dispatcher（调度器）：作为调度和中介层，负责协调控制器和视图的交互，确保控制器和视图之间的解耦。它可以管理多个视图之间的切换、视图的更新、以及不同模块之间的协调。

MCVD的好处：
- 增强解耦性：通过引入Dispatcher层，进一步解耦了视图和控制器的关系。传统MVC中，控制器直接与视图交互，这在复杂的应用中可能导致控制器和视图之间的耦合过高。
- 集中化的视图管理：Dispatcher层可以集中管理应用中的多个视图，尤其在涉及见到多视图或界面切换的复杂应用中。Dispatcher可以负责更新相应的视图和数据绑定，而无须每个控制器都去关心视图的切换和更新位问题。
- 简化控制器逻辑：传统MVC中，控制器不仅仅需要处理用户输入、还需要直接与视图进行将交互，这可能导致控制器代码变得复杂。通过引入Dispatcher层，控制器只需关注业务逻辑，减少了与视图的交互，控制器代码变得更加简洁和专注。
- 灵活的时间处理和路由机制：Dispatcher层提供了灵活的事件处理和路由机制，可以将用户的输入、请求或者视图更新事件进行路由和转发。它为事件驱动的应用程序提供了强大的支持，使得时间的流转变得更加清晰和高效。
- 易于测试和调试：通过解耦视图和控制器，MCVD模式有助于在不同层之间进行单元测试。
- 统一的界面更新机制：可以确保多视图应用程序中，界面更新的机制是一致的。避免视图同步的问题。

## 在不用智能指针的情况下如何避免内存泄漏

- 手动管理内存释放（使用后及时释放并置null）
- 遵循RAII（Resource Acquisition is Initialization）原则：将资源的管理和对象的声明周期绑定在一起（构造中new、析构中delete）
- 捕获异常并释放内存。

## C++迭代器的实现原理

迭代器是用于遍历容器元素的工具，类似于指针，可以通过它在容器中逐个访问元素。

迭代器是一个对象，它可以指向容器中的某个元素，并通过它来访问该元素，通过迭代器可以像使用指针一样进行元素访问，但它提供了对容器的抽象，使代码能在不同类型的容器间通用。

迭代器的基本操作：
- 解引用
- 自增
- 自减
- 比较

基于模板实现、实现类、对于连续内存可以直接用指针实现

## vector和list的实现原理和优缺点

vector使用连续内存来存储数据，自动扩展大小

list是双向链表

## python与C++之间交互原理

pythob和C++之间交互通常涉及嵌入和扩展，即在C++中调用Python代码、或者在Python中调用C++代码。主要依赖于Python C api以及FFI

- Python调用C++（扩展Python）：Python提供了Python C API，允许C++代码注册为Python模块，并在Python中调用。C++代码要使用Python头文件并实现Python兼容的C函数，通过PyObject处理Python对象，与Python解析器交互。然后编译成动态库供Python调用。
- C++调用Python（嵌入Python）：使用Python C API 调用


## Qt和js交互的原理是什么

Qt和JS的交互主要依赖于Qt WebEngine、Qt WebKit（老版本Qt）、以及Qt QML（QML中的JS引擎）。

Qt WebEngine允许在C++代码和Web前端(HTML + JS)之间进行通信，主要通过：
- QWebChannel（推荐）
- evaluteJavaScript()直接执行JS代码
- runJavaScript()(新版本API)，通过回调函数获取返回值
- 通过QWebEnginePage或QWebEngineView

## C++虚函数表

- vtable(虚表)：存储了该类的所有虚函数地址的数据，每个类有且只有一个虚函数表
- vptr(虚表指针)：每个含有虚函数的对象都有一个隐藏的指针，指向该对象所属的类的vtable

当调用虚函数时候：
- 通过对象的 vptr 找到vtable
- 在vatble中找到对应的虚函数地址
- 通过该地址调用函数

虚函数表存储在程序的数据区
- vtable是全局唯一的，存储在数据段（..data或.rodata）
- vptr存在对象的内存布局中（通常是对象的起始位置）

内存布局：
```c++
class Base
{
    int a;
    virtual void func();
};
```

```
// 64位系统, 单个类中包含虚函数
| vptr(8 bytes) | a (4 bytes) | padding (4 bytes)|

// 64位系统，继承的虚函数
| vptr_A | A 部分数据 | vptr_B | B 部分数据 |
```

类的内存布局：
Base 的vtable
|vtable(Base)|函数地址|
|:-----------|:-------|
|func1|Base::func1|

Derived的vtable
|vtable(Derived)|函数地址|
|:--------------|:-------|
|func1|Derived::func1|

## 链表过长怎么办

- 分块存储，每块包含一个小型数组或固定数量的节点
- 数据库存储
- 使用跳表或分段索引加速查询

## 头文件中静态变量，多个cpp包含

会有多个实例

## 模板中可以定义虚函数吗

可以定义虚函数、不可以定义纯虚函数(使用CRTP 奇异递归模板模式，可以)

## 如何找到两个子节点离的最近的公共父节点

- 递归DFS（深度有限搜索）：从根节点开始递归，查找p和q是否在当前子树中。当p和q在当前节点的左子树和右子树中则是、如果p和q在当前节点同一侧则在那一侧继续找、当前节点是p或q那可能是（但仍需检查子树）

## sort函数的实现用了什么排序

sort函数采用了Introsort（内省排序），结合了快排、堆排序和插入排序，以优化排序性能并避免最坏情况。

- 主要使用快排（O(NlogN)），但在最坏情况下（Q(N^2)）会退化，因此会检测递归深度
- 如果递归深度超过（O(logN)）则改用堆排序（O(NlogN)）
- 当分区规模比较小时候，改用插入排序（小规模数据下比快排更高效）

## 堆和栈的区别

|区别点|栈|堆|
|:-----|:-----|:-----|
|存储位置|由编译器自动管理，常在低地址（高增长方向）|由程序员手动分配和释放，在高地址|
|分配方式|自动分配|动态分配(new/delete)|
|分配速度|块(O(1))|慢(O(logN))要操作系统管理|
|存储内容|局部变量、函数参数、返回地址|大数据结构|
|作用域|局部作用域|全局作用域|
|无碎片化|无碎片化（连续内存）|可能碎片话（频繁分配和释放）|
|访问方式|LIFO（后进先出）|随机访问|
|异常处理|栈溢出|内存泄漏|

## hashmap 出现冲突怎么解决?

- 开放地址法：一个位置冲突时候，寻找下一个空的位置，直到找到一个空位置或遍历了整个hash表。线性探测（发生冲突，顺序查找下一个空槽）、二次探测（发生冲突，使用二次方程查找下一个空槽）、双重hash（使用第二个hash函数计算下一个槽位置）
- 链地址法：每个槽对应一个链表，当发生冲突时候，将冲突的元素插入到对应位置的链表中。头插、尾插

## 开链法出现聚集怎么解决？

- 重新hash
- 动态调整hash表大小
- 链表优化：优化聚集的链表，跳表或者平衡树

## 百万数据找出top10

用最小堆（O(n * log(k))）,k表示Top k的大小

## 排序法时间复杂度

## C++引用

引用是给变量提供别名的机制。它是一个以存在变量的别名，引用本身不占额外内存。引用很多情况下用于提高代码的可读性、简洁性和性能。

- 引用是已存在变量的别名，一旦引用与某个变量绑定，就无法改变引用指向其他变量
- 引用可以看作是指针的别名，但引用不像是指针那样需要解引用
- 引用必须在声明时候初始化，不能在后续改变

```c++
int a = 10;
int* p = &a; 		// 指针p，指向a
int& ref = a; 		// 引用ref，绑定到 a
```

引用用途：
- 作为函数参数传递：引用常用于函数参数传递，避免值传递时候的拷贝开销，同时又能修改函数外变量值
- 作为函数返回值：注意返回局部变量的引用会导致悬空引用，程序会出错
- 常量引用：用于传递不希望被修改的参数

### 引用高级应用

- 引用折叠

模板中，当涉及多个引用时候，会进行引用折叠，即把多个引用合并为一个引用。
例如：T&& 可能会折叠为T&或T&&

- 左值引用与右值引用折叠
```c++
template <typename T>
void f(T& x) {} // T& 左值引用

template <typename T>
void f(T&& x) {} // T&& 右值引用

// 引用折叠规则
f<int&>(x);  // T& 变成 int&，即返回左值引用
f<int&&>(x); // T&&变成 int&&, 即返回右值引用
```

- 万能引用
在模板中可以通过万能引用来接受左值或右值，并且在调用其他函数时候正确的转发

```c++
template <typename T>
void wrapper(T&& arg)
{
    some_func(std::forward<T>(arg)); // 万能引用
}
```

## 左值、右值、左值引用、右值引用

- 左值：可以出现在赋值语句左边的表达式。它代表了对象的持久位置，可以被修改或读取。左值是可以被取地址的对象或变量
- 右值：不能出现在赋值语句左边的表达式。通常是临时对象或常量。右值没有持久性，通常在表达式中产生并立即消失。
- 左值引用：是一种对左值的引用。它允许对一个左值进行引用，并可以通过它修改原始对象的值
- 右值引用：C++11引用的新概念，允许对右值（临时对象）进行引用操作，并能够实现资源的转移（移动语义）。右值引用常与移动构造函数和移动赋值运算符配合使用，用于优化对象的赋值操作，减少不必要的内存拷贝。

右值引用的用途：
- 移动语义，使得资源转移称为可能，避免对象不必要的赋值（特别是大的对象），对象中的指针转移???
- 完美转发（万能引用）：结合std::forware配合使用，实现完美转发，能够传递给其他函数原样的左值或右值，而不做任何拷贝或丢失信息。

```c++
std::move();
使用类的 MyClass::MyClass(MyClass&& other); 成员函数
MyClass& MyClass::operator=(MyClass&& other); 成员函数
```

```c++
// 错误
std::vector<int>& getVector1()
{
    std::vector<int> temp = {1, 2, 3, 4};
    return temp;
}

// 正确, 避免拷贝
std::vector<int> getVector2()
{
    std::vector<int> temp = {1, 2, 3, 4};
    return std::move(temp);
}
```

## C++什么情况下触发拷贝构造

- **以值传递对象（如果开启编译优化，拷贝构造可能被省略）**
```c++
class MyClass
{
public:
    MyClass() {}
    MyClass(const MyClass&) {}
};

void func(MyClass obj) {}

int main ()
{
    MyClass a;
    func (a);
}
```
- **以值返回对象（当函数返回一个对象的副本时候，会调用拷贝构造，但C++11及之后的编译器通常会使用返回值优化避免实际拷贝构造函数）**
```c++
MyClass createObject()
{
    MyClass obj;
    return obj;
}

int main ()
{
    MyClass a = createObject();
}
```

- **用一个已有对象初始化另一个对象**
```c++
int main ()
{
    MyClass a;
    MyClass b = a; // ==> 等价于：MyClass b (a);
}
```

- **对象作为类成员（如果类包含一个非静态成员，其类型没有默认的移动构造函数，那么在创建类对象时候，拷贝构造可能会被调用）**
```c++
class Wrapper
{
public:
    MyClass obj;
};

int main ()
{
    Wrapper w1;
    Wrapper w2 = w1; // 触发MyClass的拷贝函数
}
```

- **显示调用拷贝函数**

可以通过显示调用拷贝构造函数来创建对象

```c++
int main ()
{
    MyClass a;
    MyClass b(a); 		// 触发拷贝构造
}
```

- **STL容器存储和传递对象**

当`std::vector`、`std::list`等存储对象时候，如果元素需要扩容(relloc)或以值传递方式插入，可能会调用拷贝构造。
```c++
std::vector<MyClass> vec;
vec.push_back(MyClass()); // 可能调用拷贝构造
```
优化： `std::move()`可以避免拷贝构造，改用移动构造（C++11之后）、`emplace_back()`可以在原地构造对象，避免额外的拷贝。

- **异常抛出时候**

当对象被异常机制处理时候（例如：throw关键字），拷贝构造可能会被调用

```c++
void test()
{
    MyClass obj;
    throw obj;
}

int main ()
{
    try {
		test();
    } catch (MyClass e) { // 可能调用拷贝构造
    }
}
```

优化：使用`catch(const MyClass&)`进行引用捕获，避免拷贝

## 如何避免拷贝构造？

- 使用`const&`传递参数代替值传递
- 使用`std::move()`触发移动构造
- 使用`RVO`返回值优化：`MyClass create() {return MyClass();}`
- 使用`emplace_back()`而非`push_back()`：`vec.emplace_back(); // 直接构造，避免拷贝`

## Qt中事件的传递

Qt中的事件传递机制基于事件循环（Event Loop），核心是：事件的生成、分发和处理。

事件传递流程
1. 事件生成：由操作系统生成（如：鼠标、键盘事件）、由Qt自己（如：定时器）生成、由用户代码（如：QCoreApplication::postEvent()）主动发送
2. 事件分发：Qt事件被放入事件队列。事件循环（QEventLoop）取出事件，交给`QCoreApplication::notify()`处理。
3. 事件处理：事件首先传递给事件目标对象（QObject::event()）。若`event()`不处理，则传递给更具体的事件处理函数（如：mousePressEvent()）。若未处理，默认调用`QWidget::event()`或`QApplication::notify()`继续分发。

事件传递方向
Qt采用“自上而下” + “自下而上” 的事件传递模型：
1. 从父组件到子组件：焦点事件、键盘事件（如果QMainWindow中的QLineEdit处于焦点，当用户按下键盘，事件首先达到QMainWindow，然后传递给QLineEdit处理）
2. 从子组件到父组件：鼠标事件、绘制事件（鼠标事件QMouseEvent先传递给最前面的子组件，如果未处理，则向上传递到父组件）

事件过滤与拦截
Qt允许在事件传递过程中拦截或过滤事件：
1. 事件过滤器（installEventFilter）：可以在父对象监听子对象的事件。
2. 重写`event()`或`eventHandler()`进行拦截：`event()`拦截所有事件、具体事件处理函数：如`mousePressEvent()`、`keyPressEvent()`

事件队列
如果想异步发送事件，可以用`postEvent()`，这会将事件加入队列，等到事件循环运行时候处理（`QCoreApplication::postEvent(targetObj, new QEvent(QEvent::User));`）、立即处理事件（`QCoreApplication::sendEvent(targetObj, new QEvent(QEvent::User));`）

事件处理顺序：
1. installEventFilter()
2. QObject::event()
3. 具体事件处理函数（如：keyPressEvent()）

拦截方式：
- 外部拦截：`installEventFilter()`
- 内部拦截：重写`event()`或`eventHandler()`

事件分发方式
- 异步：`postEvent()`
- 同步：`sendEvent()`
