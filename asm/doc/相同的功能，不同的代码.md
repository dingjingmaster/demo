# 相同的功能，不同的代码

汇编语言是最有效率的计算机语言，由于直接面向处理器编程，编译后的机器代码执行起来速度也是最快的。

## 跳过非指令的数据区

- 代码 6-1
```asm
        ;代码清单6-1
        ;文件名：c06_mbr.asm
        ;文件说明：硬盘主引导扇区代码
        ;创建日期：2011-4-12 22:12
    
        jmp near start  ; 跳过数据段，从代码区开始执行

8       mytext db 'L',0x07,'a',0x07,'b',0x07,'e',0x07,'l',0x07,' ',0x07,'o',0x07,\
                'f',0x07,'f',0x07,'s',0x07,'e',0x07,'t',0x07,':',0x07
        number db 0,0,0,0,0

    start:
        mov ax,0x7c0
        mov ds,ax       ;设置数据段基地址
        mov ax,0xb800
        mov es,ax       ;设置附加段基地址

        cld
        mov si,mytext
        mov di,0
        mov cx,(number-mytext)/2        ;实际上等于 13
        rep movsw

        ;得到标号所代表的偏移地址
        mov ax,number

        ;计算各个数位
        mov bx,ax
        mov cx,5                ;循环次数
        mov si,10               ;除数

    digit:
        xor dx,dx
        div si
        mov [bx],dl
        inc bx
        loop digit

        ;显示各个数位
        mov bx,number
        mov si,4
    show:
        mov al,[bx+si]
        add al,0x30
        mov ah,0x04
        mov [es:di],ax
        add di,2
        dec si
        jns show

        mov word [es:di],0x0744

        jmp near $

    times 510-($-$$) db 0
        db 0x55,0xaa
```

> 在 NASM 里，“\”是续行符

6-1 所示，从源程序第 8 行到第 10 行，声明了非指令的数据

在程序的开始部分声明这些不可执行的内容是不安全的，为此，在这些数据之前，源程序的第 6 行，是一条转移指令 jmp near start，用来使处理器的执行流越过这些不可执行的数据，转移到后面的代码处执行。

## 在数据声明中使用字面值

显示字符串“Label offset:”的方法是将每个字符的 ASCII 码包含在每条指令中，即它们是作为每条指令的操作数出现的。这种方法很原始，也很笨拙。而且，如果要改变显示的内容，则必须重新编写指令，很不方便。

我们将要改变这种做法，使得显示字符串的手段更灵活，具体做法是专门定义一个存放字符串的数据区，当要显示它们的时候，再用指令取出来，一个一个地传送到显示缓冲区。

## 段地址初始化

汇编语言源程序的编译符合一种假设，即编译后的代码将从某个内存段中，偏移地址为 0 的地方开始加载。这样一来，如果有一个标号“label_a”，它在编译时计算的汇编地址是 0x05，那么，当程序被加载到内存后，它在段内的偏移地址仍然是 0x05，任何使用这个标号来访问内存的指令都不会产生问题。

但是，如果程序加载时，不是从段内偏移地址为 0 的地方开始的，而是 0x7c00，那么，label_a的实际偏移地址就是 0x7c05。这时，所有访问 label_a 的指令仍然会访问偏移地址 0x05，因为这是在编译时就决定了的。实际上，这样的问题在上一章就遇到过。在那里，因为我们已经知道程序将来的加载位置是 0x0000:0x7c00，所以才有了这样古怪的写法：
```asm
mov [0x7c00+number+0x00],dl
```

在主引导程序中，访问内存的指令很多，如果都要加上 0x7c00 无疑是很麻烦的，这个我们已经看到了。其实，产生这个问题的根源，就是因为程序在加载时，没有从段内偏移地址为 0 的地方开始。

我们可以把这 512 字节的区域看成一个单独的段，段的基地址是 0x07C0，段长 512字节。注意，该段的最大长度可以为 64KB。尽管 BIOS 将主引导扇区加载到物理地址 0x07c00 处，但我们却可以认为它是从 0x07c0:0x0000 处开始加载的。

在这种情况下，如果执行指令
```asm
mov [0x05],dl
```
那么，处理器将把数据段寄存器 DS 的内容（0x07c0）左移 4 位，加上指令中指定的偏移地址（0x05），形成物理内存地址 0x07c05，并将寄存器 DL 中的内容传送到该处。

所以，源程序第 13、14 行，通过传送指令将数据段寄存器 DS 的内容设置为 0x07c0。和以前一样，源程序第 16、17 行，使附加段寄存器 ES 的内容指向显示缓冲区所在的段 0xb800。

## 段之间的批量数据传送

在本章中，要在屏幕上显示的内容，连同它们的显示属性值，都集中声明在一起。想显示它们？那就要将它们“搬”到 0xB800 段。有多种方法可以做到这一点，但 8086 处理器提供了最好的方法，那就是使用 movsb 或者 movsw 指令。

这两个指令通常用于把数据从内存中的一个地方批量地传送（复制）到另一个地方，处理器把它们看成是数据串。但是，movsb 的传送是以字节为单位的，而 movsw 的传送是以字为单位的。

movsb 和 movsw 指令执行时，原始数据串的段地址由 DS 指定，偏移地址由 SI 指定，简写为DS:SI；要传送到的目的地址由 ES:DI 指定

传送的字节数（movsb）或者字数（movsw）由 CX 指定。

除此之外，还要指定是正向传送还是反向传送，正向传送是指传送操作的方向是从内存区域的低地址端到高地址端；反向传送则正好相反。正向传送时，每传送一个字节（movsb）或者一个字（movsw），SI 和 DI 加 1 或者加 2；反向传送时，每传送一个字节（movsb）或者一个字（movsw）时，SI 和 DI 减去 1 或者减去 2。不管是正向传送还是反向传送，也不管每次传送的是字节还是字，每传送一次，CX 的内容自动减一。

在 8086 处理器里，有一个特殊的寄存器，叫做标志寄存器 FLAGS。作为一个例子，它的第 6 位是 ZF（Zero Flag），即零标志。当处理器执行一条算术或者逻辑运算指令后，算术逻辑部件送出的结果除了送到指令中指定位置（目的操作数指定的位置）外，还送到一个或非门。学过逻辑电路课程，或者看过《穿越计算机的迷雾》这本书的人都知道，或非门的输入全为 0 时，输出为 1；输入不全为 0，或者全部为 1 时，输出为 0。或非门的输出送到一个触发器，这就是标志寄存器的 ZF 位。这就是说，如果计算结果为 0，这一位被置成 1，表示计算结果为零是“真”的；否则清除此位（0）。

除此之外，它也允许通过指令设置一些标志，来改变处理器的运行状态。比如，第 10 位是方向标志 DF（Direction Flag），通过将这一位清零或者置 1，就能控制 movsb 和 movsw 的传送方向。

源程序第 19 行是方向标志清零指令 cld。这是个无操作数指令，与其相反的是置方向标志指令std。cld 指令将 DF 标志清零，以指示传送是正方向的。

源程序第 20 行，设置 SI 寄存器的内容到源串的首地址，也就是标号 mytext 处的汇编地址。

源程序第 21 行，设置目的地的首地址到 DI 寄存器。屏幕上第一个字符的位置对应着 0xB800段的开始处，所以设置 DI 的内容为 0。

第 22 行，设置要批量传送的字节数到 CX 寄存器。

### 循环

loop 指令的功能是重复执行一段相同的代码，处理器在执行它的时候会顺序做两件事 ：
    - 将寄存器 CX 的内容减一；
    - 如果 CX 的内容不为零，转移到指定的位置处执行，否则顺序执行后面的指令。
```asm
loop digit
```

### 计算机中的负数

```asm
neg
```
注意数值的范围

### 处理器视角中的数据类型

无符号数和有符号数的划分并没有从根本上打消我们的疑虑，即假如寄存器 AX 中的内容是0xB23C，那么，它到底是无符号数 45628 呢，还是应当将其看成是－19908？

答案是，这是你自己的事，取决于你怎么看待它。对于处理器的多数指令来说，执行的结果和操作数的类型没有关系。换句话说，无论你是从无符号数的角度来看，还是从有符号数的角度来看，指令的执行结果都是正确无误的。比如
```
mov ah,al
```

再来考虑一下减法。考虑一下，如果要计算 10－3，这其实可以看成是 10＋（－3）。因此，使用以下三条指令就可以完成减法运算：
```
mov ah,10
mov al,-3
add ah,al
```
正是因为这个原因，很多处理器内部不构造减法电路，而是使用加法电路来做减法。

> 注意除法和乘法

我们已经学过除法指令 div。严格地说，它应该叫做无符号除法指令（Unsigned Divide），因为这条指令只能工作于无符号数。换句话说，只有从无符号数的角度来解释它的执行结果才能说得通。举个例子：
```asm
mov ax,0x0400
mov bl,0xf0
div bl
```
从无符号数的角度来看，0x0400 等于十进制数 1024，0xf0 等于十进制数 240。相除后，寄存器 AL 中的商为 0x04，即十进制数 4，完全正确。

但是，从有符号数的角度来看，0x0400 等于十进制数 1024，0xf0 等于十进制数－16。理论上，相除后，寄存器 AL 中结果应当是 0xc0。因其最高位是“1”，故为负数，即十进制数为－64。

为了解决这个问题，处理器专门提供了一个有符号数除法指令 idiv（Signed Divide）。idiv 的指令格式和 div 相同，除了它是专门用于计算有符号数的。如果你决定要进行有符号数的计算，必须采用如下代码：
```asm
mov ax,0x0400
mov bl,0xf0
idiv bl
;执行后，AL 中的内容为 0xc0，即十进制数－64
```

在用 idiv 指令做除法时，需要小心。16 位二进制数除法，结果在寄存器 AL 中。除法的结果应当是十进制数－244，遗憾的是，这样的结果超出了寄存器 AL 所能表示的范围，必然因为溢出而不正确。为此，你可能会用 32 位的除法来代替以前的做法

```asm
xor dx,dx
;如此一来，DX：AX 中的数成了正数
mov ax,0xf0c0
mov bx,0x10
idiv bl
```

很遗憾，这依然是错的。十进制数－3904 的 16 位二进制形式和 32 位二进制形式是不同的。前
者是 0xf0c0，后者是 0xfffff0c0。还记得 cwd 吗？你应该用这条指令把寄存器 AX 中数的符号扩展
到 DX。所以，完全正确的写法是这样的：

```asm
mov ax,0xf0c0
cwd
mov bx,0x10
idiv bx
```

以上指令全部执行后，寄存器 AX 中的内容为 0xff0c，即十进制数－244。主动权在你自己手上，在写程序的时候，你要做什么，什么目的，你自己最清楚。如果是无符号数计算，必须使用 div 指令；如果你是在做有符号数计算，就应当使用 idiv 指令。


## 数位的显示

一旦各个数位都分解出来了，下面的工作就是在屏幕上显示它们。源程序第 40 行，将保存有各个数位的数据区首地址传送到基址寄存器 BX。

## 其它标志位和条件转移指令

### 奇偶标志位 PF

### 进位标志位 CF

### 溢出标志位 OF

### 条件转移指令

## NASM 编译器的 `$` 和 `$$`

标记`$`，该标记等同于标号，你可以把它看成是一个隐藏在当前行行首的标号。因此，jmp near $的意思是，转移到当前指令继续执行，它和 `infi: jmp near infi` 是一样的。

标记`$$`是 NASM 编译器提供的另一个标记，代表当前汇编节（段）的起始汇编地址。当前程序没有定义节或段，就默认地自成一个汇编段，而且起始的汇编地址是 0（程序起始处）。

针对BOOT程序：用当前汇编地址减去程序开头的汇编地址（0），就是程序实体的大小。再用 510 减去程序实体的大小，就是需要填充的字节数。

就像处理器把内存划分成逻辑上的分段一样，源程序也应当按段来组织，划分成独立的代码段、数据段等。从本书第 8 章开始，将引入这方面的内容。

## 观察运行结果
