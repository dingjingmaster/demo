# 比高斯更快的计算

## 从 1 加到 100 的故事

## 显示字符串

源程序第 8 行，声明并初始化了一串字符（字符串），它的最终用途是要显示在屏幕上。我们可以直接用单引号把一串字符围起来，在编译阶段，编译器将把它们拆开，以形成一个个单独的字节。

## 堆栈 和 堆栈段 的初始化

和代码段、数据段和附加段一样，堆栈也被定义成一个内存段，叫堆栈段（Stack Segment），由段寄存器 SS 指向。

针对堆栈的操作有两种，分别是将数据推进堆栈（push）和从堆栈中弹出数据（pop）。简单地说，就是压栈和出栈。

压栈和出栈只能在一端进行，所以需要用堆栈指针寄存器 SP（Stack Pointer）来指示下一个数据应当压入堆栈内的什么位置，或者数据从哪里出栈。

定义堆栈需要两个连续的步骤，即初始化段寄存器 SS 和堆栈指针 SP 的内容。

### 分解各个数位并压栈（输出数字时候使用）

### 出栈并显示各个数位

### 进一步认识堆栈

关于堆栈，这里有几点说明。

**第一**，push 指令的操作数可以是 16 位寄存器或者指向 16 位实际操作数的内存单元地址，push 指令执行后，压入堆栈中的仅仅是该寄存器或者内存单元里的数值，与该寄存器或内存单元不再相干。所以，下面的指令是合法而且正确的：
```asm
push cs
pop ds
```
这两条指令的意思是，将代码段寄存器的内容压栈，并弹出到数据段寄存器 DS。如此一来，代码段和数据段将属于同一个内存段。实际上，这两条指令的执行结果，和以下指令的执行结果相同：

```asm
mov ax,cx
mov ds,ax
```

**第二**，堆栈在本质上也只是普通的内存区域，之所以要用 push 和 pop 指令来访问，是因为你把它看成堆栈而已。实际上，如果你把它看成是普通的数据段而忘掉它是一个堆栈，那么它将不再神秘。
引入堆栈和 push、pop 指令只是为了方便程序开发。临时保存一个数值到堆栈中，使用 push指令是最简洁、最省事的，但如果你不怕麻烦，可以不使用它。所以，下面的代码可以用来取代 pushax 指令：

```asm
sub sp,2
mov bx,sp
mov [ss:bx],ax
```
同样，pop ax 指令的执行结果和下面的代码相同：
```asm
mov bx,sp
mov ax,[ss:bx]
add sp,2
```
但是显而易见，push 和 pop 指令更方便，毕竟与堆栈访问有关的一切都是由处理器自动维护的。

**第三**，要注意保持堆栈平衡，防止数据访问越界。尤其是在编写程序前，必须充分估计所需要的堆栈空间，以防止破坏有用的数据。特别是在堆栈段和其他段属于同一个段的时候。

堆栈段和代码段属于同一个内存段，段地址都是 0x0000，段的长度都是 64KB。主引导程序的长度是 512（0x200）字节，从偏移地址 0x7c00 延伸到 0x7e00。堆栈是向下增长的，它们之间有 0xffff－0x7e00＋1＝0x8200 字节的空档。通常来说，我们的程序是安全的，因为不可能压入这么多的数据。

但是，不能掉以轻心，堆栈定义得过小，而且程序编写不当，导致堆栈破坏了有用数据的情况也时有发生。尽管不能完全阻止程序中的错误，但是，通过将堆栈定义到一个单独的 64KB 段，可能会好一点。这样，无论任何时候，即使是 push 指令位于一个无限循环中，堆栈指针寄存器 SP 的内容也永远只会在 0x0000～0xFFFF 之间来回滚动，不会影响到其他内存段。

## 程序的编译运行

## 8086处理器的寻址方式

处理器的一生，是忙碌的一生，只要它工作着，就必定是在取指令和执行指令。它就像勤劳的牛，吃的是电，挤出来的还是电，不过是另一种形式的电。^-^

如果你问处理器整天忙什么，它一定会说：“还能有什么，就是和数打交道！”既然操作和处理的是数值，那么，必定涉及数值从哪里来，处理后送到哪里去，这称为寻址方式（Addressing Mode）。简单地说，寻址方式就是如何找到要操作的数据，以及如何找到存放操作结果的地方。

### 寄存器寻址

最简单的寻址方式是寄存器寻址。就是说，指令执行时，操作的数位于寄存器中，可以从寄存器里取得。这种寻址方式的例子还是很多的，比如：
```
mov ax,cx
add bx,0xf000
inc dx
```
以上，第一条指令的两个操作数都是寄存器，是典型的寄存器寻址；第二条指令的目的操作数是寄存器，因此，该操作数也是寄存器寻址；第三条指令就更不用说了。

### 立即寻址

立即寻址又叫立即数寻址。也就是说，指令的操作数是一个立即数。比如：
```asm
add bx,0xf000
mov dx,label_a
```
以上，第一条指令的目的操作数采用了寄存器寻址方式，用于提供被加数；第二个操作数（源操作数）用于给出加数 0xf000。这是一个直接给出的数值，是立即在指令中给出的，最终参与加法运算的就是它，不需要通过其他方式寻找，故称为立即数。这也是一种寻址方式，称为立即寻址。

在第二条指令中，目的操作数也采用的是寄存器寻址方式。尽管源操作数是一个标号，但是，标号是数值的等价形式，代表了它所在位置的汇编地址。因此，在编译阶段，它会被转化为一个立即数。因此，该指令的源操作数也采用了立即寻址方式。

### 内存寻址

寄存器寻址的操作数位于寄存器中，立即寻址的操作数位于指令中，是指令的一部分。

传统上，这是两种速度较快的寻址方式。但是，它们也有局限性。一方面，我们不可能总是知道要操作的数是多少，因此也就不可能总是在指令中使用立即数；另一方面，寄存器的数量有限，不可能总指望在寄存器之间来回倒腾。

考虑到内存容量巨大，所以，在指令中使用内存地址，来操作内存中的数据，是最理想不过了。正是因为内存访问如此重要，处理器才拥有好几种内存寻址方式。

我们知道，8086 处理器访问内存时，采用的是段地址左移 4 位，然后加上偏移地址，来形成 20位物理地址的模式，段地址由 4 个段寄存器之一来提供，偏移地址要由指令来提供。因此，所谓的内存寻址，实际上就是寻找偏移地址，这称为有效地址（Effective Address，EA）。换句话说，就是如何在指令中提供偏移地址，供处理器访问内存时使用。

#### 直接寻址

使用该寻址方式的操作数是一个偏移地址，而且给出了该偏移地址的具体数值。比如：
```asm
mov ax,[0x5c0f]
add word [0x0230],0x5000
xor byte [es:label_b],0x05
```
但凡是表示内存地址的，都必须用中括号括起来。

以上，在第一条指令中，源操作数使用的是直接寻址方式，当这条指令执行时，处理器将数据段寄存器 DS 的内容左移 4 位，加上这里的 0x5c0f，形成 20 位物理地址。接着，从该物理地址处取得一个字，传送到寄存器 AX 中。

在第二条指令中，目的操作数采用的是直接寻址方式。当这条指令执行时，处理器用同样的方法，访问由段寄存器 DS 指向的数据段，并把指令中的立即数加到该段中偏移地址为 0x0230 的字单元里。

尽管在第三条指令中，目的操作数使用了标号和段超越前缀，但它依然属于直接寻址方式。原因很简单，标号是数值的等价形式，在指令编译阶段，会被转换成数值；而段超越前缀仅仅用来改变默认的数据段。

#### 基址寻址

很多时候，我们会有一大堆的数据要处理，而且它们通常都是挨在一起，顺序存放的。比如：
```asm
buffer dw 0x20,0x100,0x0f,0x300,0xff00
```

假如要将这些数据统统加一，那么，使用直接寻址的指令序列肯定是这样的：
```asm
inc word [buffer]
inc word [buffer+2]
inc word [buffer+4]
…
```
这样做好吗？当然，程序本身是没有问题的。但是，考虑到它的效率和代码的简洁性，特别是这些工作用循环来完成会更好，可以使用基址寻址。

所谓基址寻址，就是在指令的地址部分使用基址寄存器 BX 或者 BP 来提供偏移地址。比如：
```asm
mov [bx],dx
add byte [bx],0x55
```
以上，第一条指令中的目的操作数采用了基址寻址。在指令执行时，处理器将数据段寄存器DS 的内容左移 4 位，加上基址寄存器 BX 中的内容，形成 20 位的物理地址。然后，把寄存器 DX中的内容传送到该地址处的字单元里。

第二条指令中的目的操作数也采用的是基址寻址。指令执行时，将数据段寄存器 DS 的内容左移 4 位，加上寄存器 BX 中的内容，形成 20 位的物理地址。然后，将指令中的立即数 0x55 加到该地址处的字节单元里。

使用基址寻址可以使代码变得简洁高效。比如，可以用以下的代码来处理上面的批量加一任务：
```asm
    mov bx,buffer
    mov cx,4
lpinc:
    inc word [bx]
    add bx,2
    loop lpinc
```ji zhiji zhiji zhiji zhi
基址寻址的寄存器也可以是 BP。比如
```asm
mov ax,[bp]
```
这条指令的源操作数采用了基址寻址方式。但是，与前面的指令相比，它稍微有些特殊。原因在于，它采用是基址寄存器 BP，在形成 20 位的物理地址时，默认的段寄存器是 SS。也就是说，它经常用于访问堆栈。这条指令执行时，处理器将堆栈段寄存器 SS 的内容左移 4 位，加上寄存器BP 的内容，形成 20 位的物理地址，并将该地址处的一个字传送到寄存器 AX 中。

我们知道，堆栈是后进先出的数据结构，访问堆栈的一般方法是使用 push 和 pop 指令。比如我们用以下的指令压入两个数据：

```
mov ax,0x5000
push ax
mov ax,0x7000
push ax
```
很显然，如果要用 pop 指令弹出数据，就必须先弹出 0x7000，才能弹出 0x5000，除非你改变了堆栈指针 SP 的内容，否则这个顺序是不可能改变的。

但是，有时候我们希望，而且必须得越过这种限制，去访问栈中的内容，还不能破坏堆栈的状态，特别是堆栈指针寄存器 SP 的内容，使得 push 和 pop 操作能正常进行。一个典型的例子是高级语言里的函数调用，所有的参数都位于堆栈中。为了能访问到那些被压在栈底的参数，这时，BP就能派上用场：
```
mov ax,0x5000
push ax
mov bp,sp
mov ax,0x7000
push ax
mov dx,[bp]     ;dx 中的内容为 0x5000
```
以上，在压入 0x5000 之后，立即将堆栈指针 SP 保存到 BP。后面，尽管栈顶的数据 0x7000 没有出栈，但依然可以用 BP 取出压在堆栈下面的 0x5000。如此一来，正常的 push 和 pop 操作照样进行，同时，还能访问到栈中的参数。

基址寻址允许在基址寄存器的基础上使用一个偏移量。有时候，这使得它更加灵活。比如：
```asm
mov dx,[bp-2]
```
处理器在执行时，将段寄存器 SS 的内容左移 4 位，加上 BP 的内容，再减去偏移量 2 以形成物理地址。这样一来，在保持基址寄存器 BP 内容不变的情况下，就可以访问栈中的任何元素。

#### 变址寻址

变址寻址类似于基址寻址，唯一不同之处在于这种寻址方式使用的是变址寄存器（或称索引寄存器）SI 和 DI。例如：

```asm
mov [si],dx
add ax,[di]
xor word [si],0x8000
```

和基址寻址一样，当带有这种操作数的指令执行时，除非使用了段超越前缀，处理器会访问由段寄存器 DS 指向的数据段，偏移地址由寄存器 SI 或者 DI 提供。

同样地，变址寻址方式也允许带一个偏移量：
```asm
mov [si+0x100],al
and byte [di+label_a],0x80
```
以上第二条指令中，尽管使用的是标号，但本质上属于一个编译阶段确定的数值。

#### 基址变址寻址

让处理器支持多种寻址方式会增加硬件上的复杂性，但可以增强它的数据处理能力，这么做是值得的。说到数据处理，下面是一个稍微复杂一些的任务：

```asm
string db ’abcdefghijklmnopqrstuvwxyz’
```

以上声明了标号“string”并初始化了 26 个字节的数据。现在，你的任务是，将这 26 字节的数据在原地反向排列。

你可能很快想到使用堆栈，先将这 26 个数据压栈，再反向出栈，因为堆栈是后进先出的，正好符合要求。
```asm
    mov cx,26;循环次数，从 26 到 1，共 26 次
    mov bx,string;数据区首地址（基地址）
lppush:
    mov al,[bx]
    push ax
    inc bx
    loop lppush         ;循环压栈
    mov cx,26
    mov bx,string
lppop:
    pop ax
    mov [bx],al
    inc bx
    loop lppop          ;循环出栈
```
这的确是个好办法。不过，8086 处理器也支持一种基址加变址的寻址方式，简称基址变址寻址，可能用起来更方便。

使用基址变址的操作数可以使用一个基址寄存器（BX 或者 BP），外加一个变址寄存器（SI 或者 DI）。它的基本形式是这样的：

```asm
mov ax,[bx+si]
add word [bx+di],0x3000
```
以上，第一条指令的源操作数采用了基址变址寻址。当处理器执行这条指令时，把数据段寄存器 DS 的内容左移 4 位，加上基址寄存器 BX 的内容，再加上变址寄存器 SI 的内容，共同形成 20位的物理地址。然后，从该地址处取得一个字，传送到寄存器 AX 中。第二条指令与第一条指令类似，只不过是加法指令，它的目的操作数采用了基址变址寻址，源操作数采用的是立即寻址。这条指令执行时，处理器访问由段寄存器 DS 指向的数据段，加上由 BX和 DI 相加形成的偏移地址，共同形成 20 位的物理地址，然后将立即数 0x3000 加到该地址处的字单元里。

采用基址变址寻址方式的排序代码如下：

```asm
    mov bx,string;数据区首地址
    mov si,0;正向索引
    mov di,25       ;反向索引
order:
    mov ah,[bx+si]
    mov al,[bx+di]
    mov [bx+si],al
    mov [bx+di],ah  ;以上 4 行用于交换首尾数据
    inc si
    dec di
    cmp si,di
    jl order        ;首尾没有相遇，或者没有超越，继续
```

