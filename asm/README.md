# 汇编
  汇编语言是一种用于电子计算机、微处理器、微控制器或其他可编程期间的任何语言（也称符号语言）。在汇编中，用助记符代替机器指令的操作码，用地址(symbol) 或 符号(label) 代替指令或操作数的地址。特定的汇编语言与特定的机器语言指令集是一一对应的，不同平台之间不可互相移植。

## 汇编优点
  1. 程序是如何与操作系统、处理器、BIOS 交互的
  2. 数据是如何表示并存储在存储器与外部设备上的
  3. 处理器是如何访问与执行指令的，以及指令是如何访问与处理数据的
  4. 程序是如何访问外部设备的
  5. 能直接访问与硬件相关的存储器或I/O端口
  6. 能不受编译器限制，对生成的二进制代码进行完全的控制
  7. 能够对关键代码进行更准确的控制，避免因线程共同访问或者硬件设备共享引起的死锁
  8. 能够根据特定的应用对代码做最佳的优化，提高运行速度
  9. 能够最大限度的发挥硬件的功能
  10. 用汇编编写的程序比高级程序编写的程序所要求存储空间与执行时间显著减少
  11. 汇编可以使程序员完成技术性非常强的任务
  12. 对于执行要求苛刻的代码，汇编才能胜任
  13. 常驻程序、中断服务例行程序几乎都是汇编开发的

## 汇编相关
  1. 汇编器: 汇编指令转为机器码的工具

## 汇编类型
  1. 微软汇编(MASM)
  2. Borland 公司的 Trubo 汇编 (TASM)
  3. GNU 汇编器(GAS)

## 汇编数制
    计算机里内存由数字组成，计算机以二进制格式来存储所有信息

### 十进制

### 二进制

### 十六进制

## 计算机内存和CPU的基础知识

### 内存
内存的基本单元是一个字节。一台32兆内存的电脑大概容纳 3200 万字节的信息。内存里的每一个字节通过一个唯一的数字来标识他们的地址。通常内存都是大块大块的使用，而不是单个字节。

| 名称 | 大小 |
| ----- | ----- |
| 1字节 | 4bit |
| word(字) | 2个字节 |
| double word(双字) | 4个字节 |
| quad word(四字) | 8个字节 |
| paragraph(一节) | 16个字节 |

字符通过数字来表示字符的字符编码来存储，常见的两个字符编码是: ASCII和Unicode，ASCII 由1个字节表示字符，Unicode由2个字节表示字符

### CPU
中央处理器(CPU)是执行指令的物理设备。指令可能要求他们使用的数据存储在一个 CPU 称为寄存器的特殊存储位置中。CPU 可以比访问内存更快的访问寄存器数据。但是，寄存器数量是有限的，所以程序必须只保存现在使用的数据到寄存器中。

各类 CPU 执行的指令组成了该 CPU 的机器语言。机器语言拥有比高级语言更基本的结构，机器语言指令被编码成未加工的数字，而不是友好的文本格式。为了更有效的运行，CPU 必须很快的解释一个指令的目的。机器语言就是为了这一目的设计的。一个其他语言写的程序必须转换为 CPU 本地机器语言，才能在电脑上运行。

编译器是一个将用户程序语言写的程序编译成特殊结构的电脑的机器语言的程序。通常，每一类CPU都有它自己唯一的机器语言。

电脑通过使用时钟来同步指令的操作，时钟脉冲在一个固定的频率(称为时钟频率)。电子计算机通过使用这一时钟来正确的执行他们的操作，就像节拍器来帮助你正确的节奏播放音乐

#### CPU 80X86系列
Intel 80X86家族的CPU都有一些普遍的特征，包括一些基本的机器语言。
- 8088, 8086: 这写CPU从变成的观点来说是完全相同的，他们是用在早期 PC 上的 CPU。他们提供一些 16 位的寄存器：AX、BX、CX、DX、SI、DI、BP、SP、CS、DS、SS、ES、IP、FLAGS。他们仅仅支持 1M 字节的内存，而且只能工作在实模式下。在这种模式下，一个程序可以访问任何内存地址，甚至其他程序的内存，这回使排除故障和保证安全变得非常困难。而且程序的内存需要分成段，每段的内存不能大于 64K。
- 80286: 这种 CPU 使用在 FAT 系列的 PC 机中。它在 8088/86 的基本机器语言中加入了一些新的指令。然而，它主要的新特性是 16 位保护模式。在这种模式下，它可以访问 16MB 字节的内存和通过通过阻止访问其他程序的内存来保护程序。可是，程序依然是分成不能大于 64K 的段。
- 80386: 这种 CPU 极大地增强了 80286 的性能。首先它扩展了许多寄存器来容纳 32 位数据(EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP、EIP)而且增加了两个新的16位寄存器：FS、GS；增加了一个新的32位保护模式。在这种模式下，它可以访问 4G 字节。程序同样需要分成段，但是现在每段大小同样可以到 4G。
- 80486/Pentium/Pentium Pro：这些 80X86 家族的成员增加了不多的新特性。他们主要是提高了指令执行的速度。Pentium MMX：这些处理器在 Pentium 基础上增加了 MMX 指令(多媒体扩展)。这些指令可以提高普通的图像操作的速率。
- Pentium II：它是拥有 MMX 指令的 Pentium 处理器。（Pentium III 本质上就是一个更快的 Pentium II）

#### 8086 16位寄存器
最初的 8086 CPU 提供 4 个 16 位通用寄存器：AX、BX、CX 和 DX。这些寄存器都可以分解成两个 6 位寄存器。例如：AX寄存器可以分解位 AH 和 AL 寄存器。AH 寄存器包含 AX 寄存器的高 8 位，AL 寄存器包含 AX 的低 8 位。

- SI 和 DI：这是两个 16 位指针寄存器，通常他们都是作为指针来使用的，但是在许多情况下也可以像通用寄存器一样使用。但是，他们不可以分解成 8 位寄存器
- BP 和 SP：这是两个 16 位堆栈寄存器，被称为基址寄存器和堆栈指针寄存器
- CS、DS、SS 和 ES: 这是 16 位段寄存器，它们指出程序不同部分所使用的内存。CS 代表代码段、DS 代表数据段、SS 代表堆栈段、ES 代表附加段。ES 作为一个暂时段寄存器来使用
- IP 和 CS：这是两个 16 位指令指针寄存器，一起使用来跟踪 CPU 下一条指令的地址。通常，
- FLAGS：这个 16 位寄存器存储了前面指令执行结果的重要信息。这些结果在寄存器里是以单个的位存储。例如：如果前面指令执行结果位0，2位为1，繁殖位0。并不是所有指令都修改 FLAGS 里的位

#### 80386 32位 寄存器
80386 及之后的处理器扩展了寄存器。例如：16位 AX 扩展成了 32 位 EAX。其他的扩展寄存器分别是：EBX、ECX、EDX、ESI、EDI，许多其他类型的寄存器也扩展了。BP 变成了 EBP、SP 变成了 ESP、FLAGS 变成了 EFLAGS、IP 变成了 EIP。但是，不同于指针寄存器和通用寄存器，在32位保护模式下只有这些寄存器的扩展形式被使用

在80386里段寄存器依然是16位的，这儿有了两个新的段寄存器：FS 和 GS，这块使用后续补全

## 计算机实模式和保护模式

### 三种地址:
- 逻辑地址：即逻辑上的地址，实模式下由“段基址 + 段内偏移”组成；保护模式下由“段选择符 + 段内偏移”组成。
- 线性地址：逻辑地址经分段机制后就成线性地址，它是连续的；如果不启用分页，那么此线性地址即物理地址。
- 物理地址：线性地址经分页转换后就成了物理地址

### 实模式
实模式，也称实际地址模式，是所有x86兼容 CPU 下的一种操作模式。实模式的特点是 20bit 分段内存地址空间(精确到 1MB 的可寻址内存)以及对所有可寻址内存、I/O地址 和 外设硬件的无限制直接软件访问。实模式不支持内存保护、多任务处理、代码权限级别。

最早期的 8086 CPU 只有一种工作方式，那就是实模式，而且数据总线为16位，地址总线为20位，实模式下所有寄存器都是 16 位。而从 80286 开始就有了保护模式，从 80386 开始 CPU 数据总线和地址总线均为 32 位，而且寄存器都是 32 位。80386 以及现在的奔腾，酷睿等等 CPU 为了向前兼容都保留了实模式，有两种做法可以采纳：
    1. X86 CPU 在重置时都以实模式启动
    2. X86 CPU 以其他模式启动，从做系统起来后再模拟实模式
    
#### 实模式历史
1. 80286架构首次引入保护模式，允许硬件级别内存保护，但是使用这些新功能需要专为保护模式设计新的操作系统。X86 CPU 为了向后兼容，以 `实模式` 启动，为了运行 8086 和 8088 编写的操作系统。当前 x86 CPU(包括x86\_64 CPU)能够启动实模式操作系统，并且可以在不需要仿真或虚拟化的情况下运行几乎任何以前的 x86 编写的软件。
2. IBM 推出的PC BIOS 以实模式运行，DOS操作系统也是如此。现代版本的操作系统都是在启动时候将 CPU 切到保护模式，以后不再返回实模式，并且全程提供保护模式的所有好处。另外注意：80286 的保护模式更加原始；80386 的保护模式才是现代 32 位 x86 操作系统运行的模式。
    
#### 实模式寻址
8086 CPU 数据总线为 16 位，也就是一次最多取 `2^16 = 64KB` 数据，这个数据也揭示了实模式下为什么每个段最大只有 `64KB`。但是地址总线有 20 位，这样它的寻址能力应该是 `2^20 = 1MB`，这也就是实模式下 CPU 的最大寻址能力。既然他有 1MB 的寻址能力，为什么用 16 位的段寄存器表示呢？
这就引出了`分段`的概念，8086 CPU 将 1MB 存储空间分成许多逻辑段，每个段最大限长为 64KB（但不一定是 64KB）.这样每个存储单元就可以用"段基址 + 段内偏移地址" 表示段基址由 16 位段寄存器值左移 4 位表达，段内偏移表示相对于某个段起始位置的偏移量，比如：
```asm
SEG = 0X07C0
JMPI offset, #SEG
offset: MOV ax, cs
```

简单的讲，实模式就是通过 CS/DS 寄存器左移4位 + IP寄存器的值生成20位访问地址

> 需要注意两个问题：
>  1. `CS << 4 + IP`理论上来讲，最大可以表示的数值是 `0XFFFF0 + 0XFFFF = 0X10FFEF`，即大约 `1MB + 64KB - 16Bytes`，然而地址总线只有 20根，这个地址前面的 1 无法表示，当 CS = 0XFFFF 时候，实际访问的地址 0X10FFEF 就变成了 0XFFEF。即地址回到的 0 地址到 `64KB - 16Bytes` 处。
>  2. 由于程序可以任意修改当前的 CS/DS 值，所有程序可以使用全部 1MB 的内存，所以这个 CPU 几乎没办法有效的支持多任务，因为两个程序一起运行的话很容易相互踩到内存，所以系统中同时只能运行一个应用程序

### 保护模式
保护模式，即保护实际物理地址不被非法访问。

保护模式是在80286时提出，在80386上大成。具体就是80286提了的段式内存管理和80386提出的页式内存管理。所以所谓的保护物理内存的基本措施就是段页式内存管理方式。

使用了段式内存管理之后，cpu使用的就是逻辑地址，要经过段描述符表翻译才能访问实际的物理地址，而段描述符表只有系统内核 才能修改。这就保证了一个进程只能访问内核分配给他的段上的物理内存。

使用了页式内存管理之后，cpu使用的就虚拟地址，虚拟地址要经过页表翻译之后才能访问实际的物理地址上的数据，而段表只有系统内核才能修改。这就保证了一个进程只能访问内核分配给他的页上的物理内存。

实际上段式内存管理和页式内存管理就是差不多的东西，windows两个都用，采用段页式内存管理，而linux觉得完全没有必要使用段式内存管理，页式就够了，所以就使用了页式内存管理。

### 未完待续...

## 80386 CPU 内部的寄存器

### 标志寄存器 (EFLAGS)
32位长度，各标志位功能如下：

### 内存管理寄存器 (GDTR, LDTR, IDTR, TR)
一共 4 个，用于分段内存管理，都用来存放指针
|寄存器|说明|
|-----|-----|
|`GDTR`|全局描述符表寄存器，存放的是一个指向内存单元列表的指针，用于指向全局段描述表(GDT)，共48bit，高32bit是GDT基址，低16bit是GDT长度。由于每项8Byte，所以共可以有`z^(16)/8=2^13`项|
|`IDTR`|中断描述符表寄存器，存放的是一个指向内存单元列表的指针，用于指向全局中断描述附表(IDT)，共48bit，与GDTR一样|
|`LDTR`|局部描述符表寄存器，存放的是LDT的段选择字。用于从 GDT 中索引出当前任务的局部描述符表(LDT)，共16bit，高13位刚好可以索引到 GDT 的最大限长。TI置1，RPL是请求特权级用于特权检查|
|`TR`|任务寄存器，和LDTR一样，存放的是任务状态段 TSS 的段选择字。用于从 GDT 中索引出当前任务的 TSS，共 16bit|

### 控制寄存器 (CR0, CR1, CR2, CR3, CR4)
### 兼容 8086 通用寄存器 (EAX, EBX, ECX, EDX)
### 兼容 8086 段寄存器 (CS, DS, ES, SS, FS, GS)
### 兼容 8086 数据寄存器 (ESI, EDI, EIP, ESP)

## 汇编伪指令
### 处理机选择伪指令
- `.8086` 选择 8086 指令系统
- `.286` 选择 80286 指令系统
- `.286P` 选择保护方式下的 80286 指令系统
- `.386` 选择 80386 指令系统
- `.386P` 选择保护模式下的 80386 指令系统
- `.486` 选择 80486 指令系统
- `.486P` 选择保护方式下的 80486 指令系统
- `.586` 选择 Pentium 指令系统
- `.586P` 选择保护方式下的 Pentium 指令系统
> 注意，指令中的 `.` 是需要的。这类伪指令一般放在代码中的第一条指令之前即可。如果不给出，则汇编程序认为其默认选择的是 8086 指令系统

### 段定义伪指令
结合下边的程序实例来看段定义和选择 80386 指令，注意有分号的注释行，程序如下：
- 段定义和支持 386 指令
```asm
data    segment 			// 定义数据段 data
buff	db 'hello,world!$'		// 
data	ends

code    segment				// 定义代码段 code
assume  cs:code,ds:data			// 指定段寄存器和段的关系

.386					// 选择 386 指令

start:  mov ax,data			// 对 ds 赋 data 段基地址
mov  ds,ax				//
lea  bx,buff
mov  eax,'ABCD'				
mov  [bx],eax
mov  dx,offset  buff
mov  ah,9
int  21h
code ends

end  start
```
1. 段定义伪指令
汇编程序在把源程序转换为目标程序时候，只能自动确定标号和变量(代码段和数据段的符号地址)的偏移地址，程序中对于段地址也要作出说明，段地址一旦说明，该段内的指令、标号和变量都属于这个段。
段定义伪指令格式：
```asm
segment_name	SEGMENT
....
segment_name 	ENDS
```
其中 `segment_name` 由用户确定，大写的为关键字。段定义伪指令两句成对出现，两句之间为其他指令。
为了确认用户定义的段和哪个段寄存器相关联，用 `ASSUME` 伪指令来实现。
`ASSUME` 伪指令格式：
```asm
ASSUME  register_name:segment_name  ...,register_name:segment_name
```
其中 `register_name` 为段寄存器名，必须是 CS,DS,ES和SS。而 `segment_name`则必须是由段定义伪指令定义的段中的段名。

ASSUME伪指令只是指定把某个段分配给哪一个段寄存器，它并不能把段地址装入段寄存器中，所以在代码段中，还必须把段地址装入相应寄存器中。为此，还需要用两条 MOV 指令完成这一操作。但是，代码段不需要这样做，代码段的这一操作是在程序初始化时完成的。应该还记得，不允许对 CS 寄存器赋值。

2. 简化的段定义伪指令
MASM 5.0 以上版本还支持一种简化的段定义方法，可把例1程序用简化的段定义方法改写如下：
```asm
.model		small			// 定义存储类型为 small

.data					// 定义数据段
string		db 'hello,world!$ '

.code					// 定义代码段

start: mov ax,@data			// 对 ax 赋data段基地址
mov		ds,ax

mov		dx,offset string	//
mov		ah,9
int 		21h
mov		ah,4ch
int		21h
end		start
```
首先用 .MODEL 伪指令说明在内存中如何安排各个段，存储模型为 SMALL 的意思是：所有数据都放在一个 64KB 的数据段，所有代码都放在一个64KB的代码段，数据和代码都为近访问。这是最常用的一种模型。

.DATA 伪指令用来定义数据段，但没有给出段名，默认段名是 \_Data
@DATA 表示段名 \_DATA，在指令中表示段地址
简化段定义的表达能力不如 SEGMENT 伪指令那样完整而清楚，所以很多时候还是用 SEGMENT 伪指令。

3. 程序开始和结束伪指令
表示源程序结束的伪操作的格式为：`END[label]`
汇编程序将在遇到 END 时结束汇编。其中标号 label 指示程序开始执行的起始地址。如果是多个程序模块相连接，则只有主程序需要使用标号，其他子程序模块则只用 END 而不能指定标号。

4. 数据定义与存储器单元分配伪指令
指令语句的一般格式是：
```asm
[标号:]    操作码    操作数    [// 注释]
```
和指令语句格式类似，这一类伪指令的格式是：
```asm
[变量]     操作码    N个操作数 [// 注释]
```
其中变量字段是可有可无的，它用符号地址表示。其作用与指令语句前的标号相同，但它的后边不跟冒号。

操作码字段说明所用伪操作的助记符，即伪操作，说明所定义的数据类型。常用的有以下几种。
- DB: 伪操作用来定义字节，其后的每个操作数都占有一个字节(8位)
- DW：伪操作用来定义字，其后的每个操作数占有一个字(16位，其低位字节在第一个字节地址中，高位字节在第二个字节地址中，即数据低位在低地址，数据高位在高地址)。
- DD: 伪操作用来定义双字，其后的每个操作数占有两个字(32位)
- DF: 伪操作用来定义 6 个字节的字，其后的每个操作数占有48位。
- DQ: 伪操作用来定义4个字节，其后的每个操作数占有4个字(64位)，可用来存放双精度浮点数。
- DT: 伪操作用来定义10个字节，其后的每个操作数占有10个字节，为压缩的 BCD 码
(需要说明的是，MASM6 允许 DB,DW,DD,DF,DQ,DT 伪操作分别用BYTE,WORD,DWORD,FWORD,QWORD,TBYTE代替)。
这些伪操作可以把其后跟着的数据存入指定的存储单元，形成初始化数据；或者值分配存储空间而不确定数值。下面举例说明各种用法。
```asm
D_BYTE		DB	10,10H
D_WORD		DW	14,100H,-5,0ABCDH
D_DWORD		DD	4*8
```
程序中默认的数据位十进制数，10H 为十六进制数，用DB定义的数据的值不能超出一个字节所能表示的范围。数据10的符号地址是 D\_BYTE，数据 10H 的符号地址是 D\_BYTE+1。

数据可以是负数，均为补码形式存放。允许数据表达式，如 4X8，等价为 32.若数据第一位不是数字，应在前面加0，如 1ABCDH。数据在内存中的存放如图2所示。
![!01](img/01.jpeg)

操作数为字符串，问号仅预留空间。数据在内存中的存放如图2：
```asm
MESSAGE 	DB 	'HELLO?',?		// 问号通常被系统置0
DB		'AB',?
DW		'AB'				// 注意，这里'AB'作为字符串常量按字类型存放
```
![!02](img/02.jpeg)
用操作符复制操作数。数据在内存中的存放如图4所示：
![!03](img/03.jpeg)
根据需要自己定义的各类数据，含义由自己决定，数据在内存中的存放如图所示：
```asm
X1 	DB	14,3		// 十进制小数 3.14
Y2	DW	1234H,5678H	// 32位数据
Y3	DW	22,0		// 32位数据
```
![!04](img/04.jpeg)
5. 类型属性操作符
WORD	PTR		// 字类型
BYTE	PTR		// 字节类型

通常访问内存变量要知道它的符号地址，以便定位，还要知道它的类型（长度），以便匹配，如果指令中不可避免地出现两个类型（长度）不匹配的操作数时，可以在指令中对该内存变量使用类型属性操作符指定访问类型。这里注意仅是“访问类型”，并不是改变了变量本身的类型，访问类型的作用只是增加了一种访问方式，例如，对一个 8 位（或 16 位）的变量可以用 16 位（或 8 位）方式访问。




