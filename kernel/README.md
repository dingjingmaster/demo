# 内核模块

## 依赖
- 头文件
- 指定gcc版本：`cat /proc/version`

## 知识点

- 安全引导：参看 `man kernel lockdown`
- 内核模块解析命令行参数

## hello

1. 模块中必须至少有两个函数：一个在模块被插入时候调用（叫：`init_module`）；另一个在模块被移出时候调用（叫：`cleanup_module`）。早期内核必须使用这两个函数，目前可以使用任意函数名，然后通过`module_init`和`module_exit`宏设置模块的初始化调用函数和移除调用函数。
2. `__init` 宏确保初始化函数被调用后，函数被丢弃，其内存被释放（对集成到内核的模块生效，对模块没作用）。
3. `__initdata` 工作方式和`__init`一样，但是适用于变量。
4. `__exit`宏在内核模块被编译到内核中也没用（毕竟不会执行卸载操作）。
5. 内核模块命令行参数：定义变量，使用`module_param()`、`module_param_array()`、`module_param_string()`
6. 一个模块由多源文件组成
7. 模块可使用的函数在`/proc/kallsyms`
8. 区分库函数和系统调用：库函数更高级，完全运行于操作系统用户空间；系统调用则代码在内核空间运行。man 2 里有系统调用，man 3 里则是库调用。
9. 分为两种设备：块设备、字符设备
10. 设备类型
11. `seq_file`：简化读写`/proc`文件的复杂度。有三个API`start()`、`next()`、`stop()`，当读取一个 `/proc` 文件时候，开始调用`start()`，如果返回非`NULL`，则继续调用`next()`，否则调用`stop()`，每次调用`next()`之后，就会调用`show()`。
12. ioctl
13. completions：代码同步（比如：一个进程完成后再执行另一个进程），completions有三个主要部分：初始化completion同步结构体部分、通过`wait_for_completion()`等待完成、通过`complete()`发送完成信号。
14. 锁：互斥锁、自旋锁
15. 任务调度：两种运行任务的方式——任务程序和工作队列。任务程序是快速简单运行一个函数（比如：中断触发时候）；工作队列更加复杂
    - 任务程序：运行在原子操作环境内，不能休眠、不能访问用户数据
    - 工作队列
16. 中断处理。CPU 和计算机硬件中两种交互类型：CPU向硬件发送指令 + 硬件告诉CPU一些事情。
    - 检测按键按下：GPIO
17. 线程IRQ(Threaded IRQ)：用于组织线程的上半部分和下半部分，`request_irq()`中的一个处理函数分为两河部分，在`request_threadd_irq`中一次注册两个处理函数，这两个处理函数运行在不同的上下文中。上班处理程序在中断上下文中运行，它相当于传递给`request_irq()`的处理程序。另一方面，下半处理程序在自己的线程中运行。这个线程在注册线程IRQ时候创建，它的唯一目的是运行这个底部处理程序。如果`IRQ_WAKE_THREAD`由上班处理程序返回，则下半服务线程将被唤醒。然后，线程运行下半处理程序。
18. 虚拟输入设备驱动：提供一种通过事件与交互设备的通信方式。例如：键盘发送按键信息给操作系统内核。驱动将使用`input_allocate_device()`分配一个输入结构体，然后设置输入字段、设备ID、版本等。之后通过调用`input_register_device()`注册它。
