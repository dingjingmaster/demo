# kernel 0.11

## 从开机加电到执行 main 函数的过程

分三步：
1. 启动 BIOS，准备实模式下的中断向量表和中断服务程序
2. 从启动盘加载操作系统到内存，利用第一步中的中断无法程序读取磁盘上的操作系统到内存
3. 为执行 32 位的 main 函数做过度工作

## 从BIOS启动

```asm 
! 代码执行顺序：
!   1. boot/bootsect.s
!   2. boot/setup.s
!   3. boot/head.s
```

1. `上电后开始执行BIOS程序`  BIOS 位于 `0xFFFF0` 处；上电后 CS = 0xFFFF，IP =0x0000，CS:IP = 0xFFFF0
2. `BIOS初始化中断向量表`  BIOS 在内存最开始的位置(即:0x00000)用1KB的内存(0x00000 ~ 0x003FF)构建中断向量表，并在紧挨着它的位置用 256 字节的内存构建 BIOS 数据区(0x00400 ~ 0x004FF)，在大约 56KB 以后的位置(0x0E2CE)加载了8KB左右的与中断向量表相应的若干中断服务程序。中断向量表中有 256 个中断向量，每个中断向量占4个字节，其中两个字节是CS的值，两个字节是IP的值，每个中断向量都指向一个具体的中断服务程序。
3. `加载操作系统内核程序`  计算机将分三批次加载操作系统的代码。
    1. 由 BIOS 中断 `int 0x19` (中断服务程序地址在 0x0E6F2 位置处，是由BIOS设置的，会把 0磁头 0磁道 1扇区的内容复制到 0x7C00处)把第一扇区 bootsect 的内容加载到内存(bootsect有512B大小)
    2. 第2批和第3批将在 bootsect 的指挥下分别把其后的 四个扇区 和 随后的 240 个扇区内容加载到内存
    3. `bootsect` 主要功能就是读取 `setup.s`、`head.s`和操作系统`内核`(读取内核之前在屏幕打印输出："Load kernel..."字符)，读取结束后转到 `setup.s` 继续执行
    4. `setup.s` 利用BIOS提供的中断服务程序从设备上提取内核运行所需的机器系统数据（其中包括光标位置、显示页面等数据），并从中断向量 0x41和0x46所指的内存处获取硬盘参数表，放在0x9000:0x0080和0x9000:0x0090处（此时setup.s会覆盖掉 bootsect 程序所在的部分区域）；关中断，并将system从 0x10000 移动到内存的起始位置0x00000处（这一操作将BIOS建立的中断向量表覆盖掉了）！；对中断描述符表寄存器IDTR和全局描述符表寄存器GDTR进行初始化设置。；打开A20；对可编程中断控制器8259A进行重新编程；将处理器的执行模式从“实模式”转为“保护模式”，跳转到`head.s`程序。
    5. `head.s` （这里需要注意，内核的前部分是由`head.s`编译的二进制组成，后半部分由内核文件组成，其中 head 的二进制占用(25KB+184B)的空间）；head 在0x00000处建立页目录表，为分页机制做准备；将各个寄存器的用法从实模式转变为保护模式（注意：尤其段寄存器在实模式下和保护模式下的使用方法是不同的）；设置中断描述符表；废除已有的GDT，并在内核新位置重新创建全局描述符表；确定打开A20；检测数字协处理器是否存在，存在则将其设置为保护模式工作状态；将 main 函数的入口地址压栈；创建分页机制；开始执行内核的main函数
    6. 开始执行内核的`main`函数

> BIOS 一般不同，假设BIOS只有8KB，占据空间 `0xFE000 ~ 0xFFFFF`

## 从main到怠速

```c
// 代码执行顺序：
// 1. init/main.c
```

这一步需要实现三个方面的内容：
1. 用户程序能够在主机上进行运算
2. 能够与外设进行交互
3. 能够让用户以它为媒介进行人机交互

整个过程大致分为三个阶段：
1. 创建进程0，并让进程0具备在32为保护模式下在主机中运算的能力
2. 以进程0为母本创建进程1，使进程1不仅仅具备进程0所拥有的能力，而且还能以文件的形式与外设进行数据交互
3. 以进程1为母本创建进程2，使进程2在全面具备进程1所拥有的能力和环境的基础上，进一步具备人机交互的能力，最终实现怠速

怠速以后，进程2将称为创建第一个用户进程的母本，它所具备的能力将为用户程序能够以“进程”的形式正常运行提供保障。

### 开中断之前的准备工作

本阶段将创建进程0。

创建进程0起始在之前关中断后就已经开始了，包括：开启A20、初始化全局描述符表、初始化中断描述符表、设置页表和页目录等...

Linux0.1.1是支持多进程的操作系统，*多个用户进程在运行中要互不干扰*，因此要“人为”设计一套“边界”来保证这一要求，这套边界就是系统为进程提供的进程管理信息数据结构。这套结构包括：进程管理结构task_struct、进程槽task[64]、全局描述符表GDT等。

- `task_struct` 标识了进程的各项属性值，包括剩余时间片、进程执行状态、局部数据描述符表LDT、任务状态描述符表TSS ...
- `task[64]` 和 GDT 是为管理多进程而提供的数据结构，其中 task[64]中存储这系统中所有进程 task_struct 结构指针；GDT中存储这一套针对所有进程的索引结构，通过索引项，系统可以间接的与每个进程中的LDT和TSS建立关系。

### 复制根设备号和硬盘参数表

对各个硬件设备进行设置和规划前，要对“根设备号”和“硬盘参数表”进行备份






